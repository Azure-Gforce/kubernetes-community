---
kep-number: 7
title: User namespaces
authors:
  - "@adelton"
owning-sig: sig-node
participating-sigs:
reviewers:
  - TBD
  - "@derekwaynecarr"
approvers:
  - TBD
editor: TBD
creation-date: 2018-04-13
last-updated: 2018-04-13
status: provisional
see-also:
replaces:
superseded-by:
---

# User namespaces

## Table of Contents

   * [User namespaces](#user-namespaces)
      * [Table of Contents](#table-of-contents)
      * [Summary](#summary)
      * [Motivation](#motivation)
         * [Goals](#goals)
         * [Non-Goals](#non-goals)
      * [Proposal](#proposal)
         * [User Stories / Options](#user-stories--options)
            * [Option 1: Single system-wide user namespace](#option-1-single-system-wide-user-namespace)
            * [Option 2: Named user namespace](#option-2-named-user-namespace)
            * [Option 3: Unique auto-generated user namespace](#option-3-unique-auto-generated-user-namespace)
         * [Implementation Details/Notes/Constraints](#implementation-detailsnotesconstraints)
            * [How is a specific namespace identified?](#how-is-a-specific-namespace-identified)
            * [How do we name the “I do not care as long as it is unique” user namespace?](#how-do-we-name-the-i-do-not-care-as-long-as-it-is-unique-user-namespace)
            * [How do we grant access to a namespace?](#how-do-we-grant-access-to-a-namespace)
            * [References](#references)
         * [Risks and Mitigations](#risks-and-mitigations)
      * [Graduation Criteria](#graduation-criteria)
      * [Implementation History](#implementation-history)
      * [Drawbacks](#drawbacks)
      * [Alternatives](#alternatives)

TOC generated by [gh-md-toc](https://github.com/ekalinin/github-markdown-toc)

## Summary

In order to run Pods with software which expects to run as root or
with elevated privileges while still containing the processes and
protecting both the Nodes and other Pods, Linux kernel mechanism of
user namespaces can be used make the processes in the Pods view their
environment as having the privileges, while on the host (Node) level
these processes appear as without privileges, or with privileges only
affecting processes in the same Pods.

In this proposal we look at three options of supporting and exposing
the feature, showing the way of gradual deployment of the feature
based both on the capabilities of the underlying Container Runtime,
and to give admins and users mechanism to enable the feature
gradually, to allow for testing and discovering regressions in their
payloads.

## Motivation

From user_namespaces(7):
> User namespaces isolate security-related identifiers and attributes,
> in particular, user IDs and group IDs, the root directory, keys,
> and capabilities.  A process's user and group IDs can be different
> inside and outside a user namespace.  In particular, a process can
> have a normal unprivileged user ID outside a user namespace while
> at the same time having a user ID of 0 inside the namespace;
> in other words, the process has full privileges for operations
> inside the user namespace, but is unprivileged for operations
> outside the namespace.

The purpose of using user namespaces in Kubernetes is to let the
processes in Pods think they run as one uid set when in fact they run
as different “real” uids on the Nodes.

In this text, most everything said about uids can also be applied to gids.

### Goals

The goal is to be able to take container images that would all want to
run as the same uid (0 for root, 48 for apache, some 997 for nginx)
or set of uids (systemd-based multi-daemon container which starts as
uid 0 and forks a number of service running as different uids) and run
them without clashing with the same uids on the host, or among
containers themselves. So the set of uids that the containers will need
mapped is known before the container is started.

The effort will be successful when it will be possible to use any
container image, built using any set of uids, and run it in Kubernetes
cluster safely with runtime uids not matching those in the image.
Specifically, Pods with containers that need to be run as root (uid 0)
should be runnable with non-root uids, and systemd-based containers
need to be supported.

### Non-Goals

The goal is not to support use cases when the uids for processes get
allocated in runtime and externally (IPA, Active Directory) for generic
users, without specifying (hopefully narrow) range of uids to be mapped
upfront, before the container gets started.

## Proposal

This is where we get down to the nitty gritty of what the proposal actually is.

### User Stories / Options

#### Option 1: Single system-wide user namespace

The goal is to protect the Node from the Containers, allowing, for
example, root processes in Pods to run as non-0 uid on the host.

This is what the docker daemon supports today with its
`--userns-remap` option and what is coming to CRI-O with
`--userns-uid-map`.

For things to work with persistent storage, the same settings in
`/etc/sysconfig/docker` and `/etc/subuid` need to be on all Nodes for
docker. For CRI-O, the same consistency across the Nodes can be
ensured in `/etc/sysconfig/crio-storage`.

With this option, Kubernetes needs to match the user namespace settings
of the Container Runtime, without any expectation of affecting the
settings.

The user should have a mechanism to request `host` user namespace,
overriding the Container Runtime default.

#### Option 2: Named user namespace

Requested in Pod’s spec, permitted by PSP, with optional per-Namespace default.

The goal is to have isolation of the Node from Containers and Pods among
themselves, while having control of the actual uids used.

Having the control of the “real” uids is needed for shared storage.

Namespace can be identified using its definition (the content of the
`/proc/<pid>/uid_map` file or sets of three integers) or possibly by
some string, a key to that content on Kubernetes cluster level.

That list of three integers is both in OCI Runtime Specification
(https://github.com/opencontainers/runtime-spec/blob/master/config-linux.md#user-namespace-mappings)
and used in containers/storage
(https://github.com/containers/storage/blob/master/pkg/idtools/idtools.go#L15)
so that’s what needs to be exposed on Kubernetes level.

Note: the `/etc/subuid` file is an authorization mechanism for the
`newuidmap` command rather than a definition mechanism as used by the
docker daemon’s `--userns-remap` option or CRI-O's future
`--userns-uid-map-user`. For this Option 2, this mechanism shouldn't
be used.

#### Option 3: Unique auto-generated user namespace

Requested by Pod’s spec, permitted by PSP, with optional per-Namespace default.

The goal is to isolate Pods among themselves (and from the Node) without
the admin or user having to allocate the uid ranges manually.

For allocation purposes, it will be necessary to know how many and what
uids the Containers in the Pod needs supported. So the “request” in
Pod’s spec might be in the form of list of uids that the Pod needs mapped.

In addition, that information could also be present in Images -- in
that case, Pod’s spec might say “map all uids listed in the images
from which the Containers get started”. It would then be an error if
the Image did not specify any uids.

### Implementation Details/Notes/Constraints

What are the caveats to the implementation?
What are some important details that didn't come across above.
Go in to as much detail as necessary here.
This might be a good place to talk about core concepts and how they releate.

#### How is a specific namespace identified?

Already instantiated namespace on the Node via `/proc/<pid>/ns/user`.

It’s semantics by `/proc/<pid>/uid_map`.

Uninstantiated namespace (namespace definition) by content which can be
written to `/proc/<pid>/uid_map`.

Or some key mapping to the above, for easier human consumption.

#### How do we name the “I do not care as long as it is unique” user namespace?

It can be some (equivalent of) `runAsUser` attribute.

Ideally, it will become the default, to be overridden by specifying
a particular uid mapping or specifying that host mapping (0 0 4294967295)
ought to be used.

#### How do we grant access to a namespace?

PSP can define list of allowed user namespaces, either by their content
(listing ranges of host uids that can be used) or by name.

For the autogenerated unique user namespaces, PSP can control how many
uids the Pod is allowed to allocate. The default could be 1, to always
allow single-uid Pods to start.

#### References

* Enable userns support for containers launched by kubelet
  * https://github.com/kubernetes/features/issues/127
* Track Linux User Namespaces in the Pod Security Policy
  * https://github.com/kubernetes/kubernetes/issues/59152
* Add support for `experimental-userns-remap-root-uid` and `experimental-userns-remap-root-gid` options to match the remapping used by the container runtime.
  * https://github.com/kubernetes/kubernetes/pull/55707
* rkt User Namespaces Background
  * https://coreos.com/rkt/docs/latest/devel/user-namespaces.html

### Risks and Mitigations

* The main risk with this change stems from the fact that processes in
Pods will run with different “real” uids than they used to, while
expecting the original uids to make operations on the Nodes or
consistently access shared persistent storage.
  * This can be mitigated by turning the feature on gradually, per-Pod
or per Kubernetes namespace.
  * For the Kubernetes' cluster Pods (that provide the Kubernetes
functionality), testing of their behaviour and ability to run in user
namespaced setups is crucial.

## Graduation Criteria

Success will be achieved when out of box or with little configuration,
Kubernetes' Pods will run as non-root non-system uids, random images
from public registries will automatically run user namespaced while
internally thinking they run as root or system uid, and admins will have
means to control the uid mappings and allocations.

Hopefully the content previously contained in [umbrella issues][] will be tracked in the `Graduation Criteria` section.

[umbrella issues]: https://github.com/kubernetes/kubernetes/issues/42752

## Implementation History

Major milestones in the life cycle of a KEP should be tracked in `Implementation History`.
Major milestones might include

- the `Summary` and `Motivation` sections being merged signaling SIG acceptance
- the `Proposal` section being merged signaling agreement on a proposed design
- the date implementation started
- the first Kubernetes release where an initial version of the KEP was available
- the version of Kubernetes where the KEP graduated to general availability
- when the KEP was retired or superseded

## Drawbacks

*

## Alternatives

*

