# Auditing

Cao Shufeng (@CaoShuFeng)

## Abstract

This proposal aims at managing coredump files generated in cluster containers.

## Motivation and Goals

Application coredump is one of required feature for enterprise systems. In Kubernetes, we need to take "multi-tenancy" and "security" into account. Technically, under Linux, each server’s coredump can be controlled via [/proc/sys/kernel/core_pattern](http://man7.org/linux/man-pages/man5/core.5.html) of the host. By this, an application coredump can be passed into host’s special file or special program. We need to build API to specify
- Where coredumps should be stored and access control to them
  - typically, namespaced persistent storage rather than host’s file system
  - list/get/delete coredump and metadata
  - access control to dumped data
  - quota for coredump for each namespace
  - no core dump label for specific environment (such as development environ)


## Community Work

- make core_pattern support namespace in kernel (not approved yet): https://lkml.org/lkml/2017/2/7/931

## Proposed Design

To implement this, we need to make the following three changes on kubernetes.
- create a new special program integrated with kuberentes’s API and put it into /proc/sys/kernel/core_pattern.  The program is used to determine process in which container generated the core file.
- Specify persistent storage in pods to store coredump file and set quota per namespace. Also users should be able to download the coredump file through kubernetes api.
- Add new rest API in kube-apiserver for users to get/list/delete core file metadata.


### API design
1. A new persistent volume is add to PodSpec to store coredump file(Note: no container in this pod should mount it)
```go
// PodSpec is a description of a pod
type PodSpec struct {
    //CoredumpVolume is a persistent volume used to store coredump, if empty, no coredump will be stored.
    CoredumpVolume Volume
}
```
2. A new rest API coredump is add to kubernetes
```go
// Coredump contains metadata information about a coredump file
type Coredump struct {
    metav1.TypeMeta
    // Standard object's metadata.
    // +optional
    metav1.ObjectMeta
    Spec CoredumpSpec
    Status CoredumpStatus
}
// CoredumpSpec contains information where the coredump is generated and where it's stored
type CoredumpSpec {
    // Node is the kubelet node where coredump happened
    Node String
    // Pod is the pod where coredump happened
    Pod String
    // The container where coredump happened
    Container String
    // The size of the coredump file.
    Size integer
    // Where the coredump is stored.
    Volume Volume
}
// CoredumpStatus contains information 
type CoredumpStatus struct {
    // Phase indicates if a coredump file is available
    // +optional
    Phase CoredumpPhase
    // A human-readable message indicating details about why the coredump is in this state.
    // +optional
    Message string
    // Reason is a brief CamelCase string that describes any failure and is meant for machine parsing and tidy display in the CLI
    // +optional
    Reason string
}
type CoredumpPhase string
```

### a new kube-coredump program
To determine whether a core file is generated for process in a k8s container, we need to override /proc/sys/kernel/core_pattern kernel parameter in kubelet node, as:
$ echo '|/bin/kube-coredump %p %P %t' > /proc/sys/kernel/core_pattern
%p :PID of dumped process, as seen in the PID namespace in which the process resides
%P :PID of dumped process, as seen in the initial PID namespace
%t : time of dump, expressed as seconds since the Epoch
Kube-coredump will do three things:
1. Check whether the core file is generated by a process in k8s container.
We can get all running pods through kubelet rest API:
https://localhost:10250/runningpods/
Run `docker top` for each running k8s containers. If the container has the same PID with %P argument, then the core file is generated for process in that container.
2. Register this core file to kube-apiserver
Kube-apiserver will check quota for coredump file size when registering.
3. Save the core file to filesystem
If this core file is registered successfully, then we save the core to filesystem.
$ cat - > /var/kube-coredumps/{namespace}/{pod}/{container}/{time}
TODO: What do we do with core files generated by host or other containers?

### coredump controller
Kube-controller-manager will watch the list of coredump files, if a coredump is registered, a temporary pod will be scheduled to the coredump file’s node, and the pod will copy the coredump file form host directory to persistent volume. If a coredump is deleted form kube-apiserver, kube-controller-manager will start a pod to delete the coredump file from persistent volume.

### downloading and access control
Since coredump file has been stored in persistent volume, user can mount the volume to a pod and download the coredump file, for example : "kubectl cp". Administrator can use RBAC to specify access control to coredump metadata, and user can only access coredump files stored in persistent volume which he has access rithts.
TODO: Do we need a feature like "kubectl coredump download"?

